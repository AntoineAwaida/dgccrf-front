{"ast":null,"code":"import axios from 'axios';\nimport config from '../config';\nimport moment from 'moment';\n\nclass Replication {\n  constructor(db, replicationUrl, storageKey, time = 10000) {\n    this.db = db;\n    this.replicationUrl = replicationUrl;\n    this.storageKey = storageKey;\n    this.tryReplication = this.tryReplication.bind(this);\n    this.stopReplication = this.stopReplication.bind(this);\n    this.tryReplication().then(() => {\n      this.interval = window.setInterval(this.tryReplication, time);\n    });\n  }\n\n  stopReplication() {\n    window.clearInterval(this.interval);\n    window.localStorage.removeItem(this.storageKey);\n  }\n\n  async tryReplication() {\n    let rawNextChangeDate = localStorage.getItem(this.storageKey);\n    let nextChangeDate = moment(rawNextChangeDate).format('YYYY-MM-DDTHH:mm:SSS');\n\n    if (!rawNextChangeDate || nextChangeDate < moment(new Date()).format('YYYY-MM-DDTHH:mm:SSS')) {\n      try {\n        let _ref = await axios.get(this.replicationUrl),\n            data = _ref.data;\n\n        await this.db.bulkDocs({\n          docs: data\n        });\n        localStorage.setItem(this.storageKey, this.getNextReplicationDate());\n      } catch (err) {\n        if (err.response) {} // else no response received that means the user is offline (or the server is not working)\n\n      }\n    }\n  }\n\n  getNextReplicationDate() {\n    let replicationHour = config.replication_starting_hour; // at 9am every morning the new data is here we have to refetch it\n\n    let date = new Date();\n    let nextDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), replicationHour);\n\n    if (date.getHours() >= replicationHour) {\n      nextDate.setDate(nextDate.getDate() + 1);\n    }\n\n    return nextDate;\n  }\n\n}\n\nconst replicateFromSQL = (db, replicationUrl, storageKey) => {\n  return new Replication(db, replicationUrl, storageKey);\n};\n\nexport default replicateFromSQL;","map":{"version":3,"sources":["/Users/antoine/Documents/DGCCRF/dgccrf-front/src/services/replicationHandler.js"],"names":["axios","config","moment","Replication","constructor","db","replicationUrl","storageKey","time","tryReplication","bind","stopReplication","then","interval","window","setInterval","clearInterval","localStorage","removeItem","rawNextChangeDate","getItem","nextChangeDate","format","Date","get","data","bulkDocs","docs","setItem","getNextReplicationDate","err","response","replicationHour","replication_starting_hour","date","nextDate","getFullYear","getMonth","getDate","getHours","setDate","replicateFromSQL"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,MAAP,MAAmB,QAAnB;;AAEA,MAAMC,WAAN,CAAkB;AAChBC,EAAAA,WAAW,CAACC,EAAD,EAAKC,cAAL,EAAqBC,UAArB,EAAiCC,IAAI,GAAG,KAAxC,EAA+C;AACxD,SAAKH,EAAL,GAAUA,EAAV;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AAEA,SAAKE,cAAL,GAAsB,KAAKA,cAAL,CAAoBC,IAApB,CAAyB,IAAzB,CAAtB;AACA,SAAKC,eAAL,GAAuB,KAAKA,eAAL,CAAqBD,IAArB,CAA0B,IAA1B,CAAvB;AAEA,SAAKD,cAAL,GAAsBG,IAAtB,CAA2B,MAAM;AAC/B,WAAKC,QAAL,GAAgBC,MAAM,CAACC,WAAP,CAAmB,KAAKN,cAAxB,EAAwCD,IAAxC,CAAhB;AACD,KAFD;AAGD;;AAEDG,EAAAA,eAAe,GAAG;AAChBG,IAAAA,MAAM,CAACE,aAAP,CAAqB,KAAKH,QAA1B;AACAC,IAAAA,MAAM,CAACG,YAAP,CAAoBC,UAApB,CAA+B,KAAKX,UAApC;AACD;;AAED,QAAME,cAAN,GAAuB;AACrB,QAAIU,iBAAiB,GAAGF,YAAY,CAACG,OAAb,CAAqB,KAAKb,UAA1B,CAAxB;AACA,QAAIc,cAAc,GAAGnB,MAAM,CAACiB,iBAAD,CAAN,CAA0BG,MAA1B,CACnB,sBADmB,CAArB;;AAGA,QACE,CAACH,iBAAD,IACAE,cAAc,GAAGnB,MAAM,CAAC,IAAIqB,IAAJ,EAAD,CAAN,CAAmBD,MAAnB,CAA0B,sBAA1B,CAFnB,EAGE;AACA,UAAI;AAAA,mBACa,MAAMtB,KAAK,CAACwB,GAAN,CAAU,KAAKlB,cAAf,CADnB;AAAA,YACImB,IADJ,QACIA,IADJ;;AAEF,cAAM,KAAKpB,EAAL,CAAQqB,QAAR,CAAiB;AAAEC,UAAAA,IAAI,EAAEF;AAAR,SAAjB,CAAN;AACAR,QAAAA,YAAY,CAACW,OAAb,CAAqB,KAAKrB,UAA1B,EAAsC,KAAKsB,sBAAL,EAAtC;AACD,OAJD,CAIE,OAAOC,GAAP,EAAY;AACZ,YAAIA,GAAG,CAACC,QAAR,EAAkB,CACjB,CAFW,CAEV;;AACH;AACF;AACF;;AAEDF,EAAAA,sBAAsB,GAAG;AACvB,QAAIG,eAAe,GAAG/B,MAAM,CAACgC,yBAA7B,CADuB,CACiC;;AACxD,QAAIC,IAAI,GAAG,IAAIX,IAAJ,EAAX;AACA,QAAIY,QAAQ,GAAG,IAAIZ,IAAJ,CACbW,IAAI,CAACE,WAAL,EADa,EAEbF,IAAI,CAACG,QAAL,EAFa,EAGbH,IAAI,CAACI,OAAL,EAHa,EAIbN,eAJa,CAAf;;AAMA,QAAIE,IAAI,CAACK,QAAL,MAAmBP,eAAvB,EAAwC;AACtCG,MAAAA,QAAQ,CAACK,OAAT,CAAiBL,QAAQ,CAACG,OAAT,KAAqB,CAAtC;AACD;;AACD,WAAOH,QAAP;AACD;;AApDe;;AAuDlB,MAAMM,gBAAgB,GAAG,CAACpC,EAAD,EAAKC,cAAL,EAAqBC,UAArB,KAAoC;AAC3D,SAAO,IAAIJ,WAAJ,CAAgBE,EAAhB,EAAoBC,cAApB,EAAoCC,UAApC,CAAP;AACD,CAFD;;AAIA,eAAekC,gBAAf","sourcesContent":["import axios from 'axios';\nimport config from '../config';\nimport moment from 'moment';\n\nclass Replication {\n  constructor(db, replicationUrl, storageKey, time = 10000) {\n    this.db = db;\n    this.replicationUrl = replicationUrl;\n    this.storageKey = storageKey;\n\n    this.tryReplication = this.tryReplication.bind(this);\n    this.stopReplication = this.stopReplication.bind(this);\n\n    this.tryReplication().then(() => {\n      this.interval = window.setInterval(this.tryReplication, time);\n    });\n  }\n\n  stopReplication() {\n    window.clearInterval(this.interval);\n    window.localStorage.removeItem(this.storageKey);\n  }\n\n  async tryReplication() {\n    let rawNextChangeDate = localStorage.getItem(this.storageKey);\n    let nextChangeDate = moment(rawNextChangeDate).format(\n      'YYYY-MM-DDTHH:mm:SSS'\n    );\n    if (\n      !rawNextChangeDate ||\n      nextChangeDate < moment(new Date()).format('YYYY-MM-DDTHH:mm:SSS')\n    ) {\n      try {\n        let { data } = await axios.get(this.replicationUrl);\n        await this.db.bulkDocs({ docs: data });\n        localStorage.setItem(this.storageKey, this.getNextReplicationDate());\n      } catch (err) {\n        if (err.response) {\n        } // else no response received that means the user is offline (or the server is not working)\n      }\n    }\n  }\n\n  getNextReplicationDate() {\n    let replicationHour = config.replication_starting_hour; // at 9am every morning the new data is here we have to refetch it\n    let date = new Date();\n    let nextDate = new Date(\n      date.getFullYear(),\n      date.getMonth(),\n      date.getDate(),\n      replicationHour\n    );\n    if (date.getHours() >= replicationHour) {\n      nextDate.setDate(nextDate.getDate() + 1);\n    }\n    return nextDate;\n  }\n}\n\nconst replicateFromSQL = (db, replicationUrl, storageKey) => {\n  return new Replication(db, replicationUrl, storageKey);\n};\n\nexport default replicateFromSQL;\n"]},"metadata":{},"sourceType":"module"}