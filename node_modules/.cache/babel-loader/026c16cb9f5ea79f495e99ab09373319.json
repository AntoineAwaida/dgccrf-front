{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar isNil_1 = __importDefault(require(\"lodash/isNil\"));\n\nvar invoke_1 = __importDefault(require(\"lodash/invoke\"));\n\nvar moment_1 = __importDefault(require(\"moment\"));\n\nvar PropTypes = __importStar(require(\"prop-types\"));\n\nvar React = __importStar(require(\"react\"));\n\nvar CustomPropTypes_1 = __importDefault(require(\"../lib/CustomPropTypes\"));\n\nvar DayPicker_1 = __importDefault(require(\"../pickers/dayPicker/DayPicker\"));\n\nvar MonthPicker_1 = __importDefault(require(\"../pickers/monthPicker/MonthPicker\"));\n\nvar HourPicker_1 = __importDefault(require(\"../pickers/timePicker/HourPicker\"));\n\nvar MinutePicker_1 = __importDefault(require(\"../pickers/timePicker/MinutePicker\"));\n\nvar YearPicker_1 = __importDefault(require(\"../pickers/YearPicker\"));\n\nvar InputView_1 = __importDefault(require(\"../views/InputView\"));\n\nvar BaseInput_1 = __importDefault(require(\"./BaseInput\"));\n\nvar lib_1 = require(\"../lib\");\n\nvar parse_1 = require(\"./parse\");\n\nvar shared_1 = require(\"./shared\");\n\nvar nextMode = {\n  year: 'month',\n  month: 'day',\n  day: 'hour',\n  hour: 'minute',\n  minute: 'year'\n};\n\nfunction getNextMode(currentMode) {\n  return nextMode[currentMode];\n}\n\nvar prevMode = {\n  minute: 'hour',\n  hour: 'day',\n  day: 'month',\n  month: 'year',\n  year: 'minute'\n};\n\nfunction getPrevMode(currentMode) {\n  return prevMode[currentMode];\n}\n\nvar DateTimeInput =\n/** @class */\nfunction (_super) {\n  __extends(DateTimeInput, _super);\n\n  function DateTimeInput(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.componentDidUpdate = function (prevProps) {\n      // update internal date if ``value`` prop changed and successuffly parsed\n      if (prevProps.value !== _this.props.value) {\n        var parsed = parse_1.parseValue(_this.props.value, _this.getDateTimeFormat(), _this.props.localization);\n\n        if (parsed) {\n          _this.setState({\n            year: parsed.year(),\n            month: parsed.month(),\n            date: parsed.date(),\n            hour: parsed.hour(),\n            minute: parsed.minute()\n          });\n        }\n      }\n    };\n\n    _this.switchToNextModeUndelayed = function () {\n      _this.setState(function (_a) {\n        var mode = _a.mode;\n        return {\n          mode: getNextMode(mode)\n        };\n      }, _this.onModeSwitch);\n    };\n\n    _this.switchToNextMode = function () {\n      lib_1.tick(_this.switchToNextModeUndelayed);\n    };\n\n    _this.switchToPrevModeUndelayed = function () {\n      _this.setState(function (_a) {\n        var mode = _a.mode;\n        return {\n          mode: getPrevMode(mode)\n        };\n      }, _this.onModeSwitch);\n    };\n\n    _this.switchToPrevMode = function () {\n      lib_1.tick(_this.switchToPrevModeUndelayed);\n    };\n\n    _this.handleSelect = function (e, _a) {\n      var value = _a.value;\n      lib_1.tick(_this.handleSelectUndelayed, e, {\n        value: value\n      });\n    };\n\n    _this.onFocus = function () {\n      if (!_this.props.preserveViewMode) {\n        _this.setState({\n          mode: _this.props.startMode\n        });\n      }\n    };\n\n    _this.handleSelectUndelayed = function (e, _a) {\n      var value = _a.value;\n\n      if (_this.props.closable && _this.state.mode === 'minute') {\n        _this.closePopup();\n      }\n\n      _this.setState(function (prevState) {\n        var mode = prevState.mode;\n\n        if (mode === 'minute') {\n          var outValue = moment_1.default(value).format(_this.getDateTimeFormat());\n          invoke_1.default(_this.props, 'onChange', e, __assign({}, _this.props, {\n            value: outValue\n          }));\n        }\n\n        return {\n          year: value.year,\n          month: value.month,\n          date: value.date,\n          hour: value.hour,\n          minute: value.minute\n        };\n      }, function () {\n        return _this.state.mode !== 'minute' && _this.switchToNextMode();\n      });\n    };\n    /** Keeps internal state in sync with input field value. */\n\n\n    _this.onInputValueChange = function (e, _a) {\n      var value = _a.value;\n      var parsedValue = moment_1.default(value, _this.getDateTimeFormat());\n\n      if (parsedValue.isValid()) {\n        _this.setState({\n          year: parsedValue.year(),\n          month: parsedValue.month(),\n          date: parsedValue.date(),\n          hour: parsedValue.hour(),\n          minute: parsedValue.minute()\n        });\n      }\n\n      invoke_1.default(_this.props, 'onChange', e, __assign({}, _this.props, {\n        value: value\n      }));\n    };\n\n    var parsedValue = parse_1.parseValue(props.value, _this.getDateTimeFormat(), props.localization);\n    _this.state = {\n      mode: props.startMode,\n      year: parsedValue ? parsedValue.year() : undefined,\n      month: parsedValue ? parsedValue.month() : undefined,\n      date: parsedValue ? parsedValue.date() : undefined,\n      hour: parsedValue ? parsedValue.hour() : undefined,\n      minute: parsedValue ? parsedValue.minute() : undefined,\n      popupIsClosed: true\n    };\n    return _this;\n  }\n\n  DateTimeInput.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        value = _a.value,\n        dateTimeFormat = _a.dateTimeFormat,\n        dateFormat = _a.dateFormat,\n        timeFormat = _a.timeFormat,\n        initialDate = _a.initialDate,\n        disable = _a.disable,\n        maxDate = _a.maxDate,\n        minDate = _a.minDate,\n        preserveViewMode = _a.preserveViewMode,\n        startMode = _a.startMode,\n        divider = _a.divider,\n        closable = _a.closable,\n        markColor = _a.markColor,\n        marked = _a.marked,\n        localization = _a.localization,\n        onChange = _a.onChange,\n        rest = __rest(_a, [\"value\", \"dateTimeFormat\", \"dateFormat\", \"timeFormat\", \"initialDate\", \"disable\", \"maxDate\", \"minDate\", \"preserveViewMode\", \"startMode\", \"divider\", \"closable\", \"markColor\", \"marked\", \"localization\", \"onChange\"]);\n\n    return React.createElement(InputView_1.default, __assign({\n      popupIsClosed: this.state.popupIsClosed,\n      closePopup: this.closePopup,\n      openPopup: this.openPopup,\n      onFocus: this.onFocus,\n      onMount: this.onInputViewMount,\n      onChange: this.onInputValueChange\n    }, rest, {\n      value: parse_1.dateValueToString(value, dateFormat, localization),\n      renderPicker: function () {\n        return _this.getPicker();\n      }\n    }));\n  };\n\n  DateTimeInput.prototype.parseInternalValue = function () {\n    /*\r\n      Creates moment instance from values stored in component's state\r\n      (year, month, date, hour, minute) in order to pass this moment instance to\r\n      underlying picker.\r\n      Return undefined if none of these state fields has value.\r\n    */\n    var _a = this.state,\n        year = _a.year,\n        month = _a.month,\n        date = _a.date,\n        hour = _a.hour,\n        minute = _a.minute;\n\n    if (!isNil_1.default(year) || !isNil_1.default(month) || !isNil_1.default(date) || !isNil_1.default(hour) || !isNil_1.default(minute)) {\n      return moment_1.default({\n        year: year,\n        month: month,\n        date: date,\n        hour: hour,\n        minute: minute\n      });\n    }\n  };\n\n  DateTimeInput.prototype.getDateTimeFormat = function () {\n    var _a = this.props,\n        dateFormat = _a.dateFormat,\n        divider = _a.divider,\n        timeFormat = _a.timeFormat,\n        dateTimeFormat = _a.dateTimeFormat;\n    return dateTimeFormat || \"\" + dateFormat + divider + parse_1.TIME_FORMAT[timeFormat];\n  };\n\n  DateTimeInput.prototype.getPicker = function () {\n    var _a = this.props,\n        value = _a.value,\n        initialDate = _a.initialDate,\n        dateFormat = _a.dateFormat,\n        disable = _a.disable,\n        minDate = _a.minDate,\n        maxDate = _a.maxDate,\n        inline = _a.inline,\n        marked = _a.marked,\n        markColor = _a.markColor,\n        localization = _a.localization,\n        tabIndex = _a.tabIndex,\n        pickerStyle = _a.pickerStyle,\n        pickerWidth = _a.pickerWidth;\n    var dateTimeFormat = this.getDateTimeFormat();\n    var pickerProps = {\n      tabIndex: tabIndex,\n      isPickerInFocus: this.isPickerInFocus,\n      isTriggerInFocus: this.isTriggerInFocus,\n      inline: inline,\n      pickerWidth: pickerWidth,\n      pickerStyle: pickerStyle,\n      onCalendarViewMount: this.onCalendarViewMount,\n      closePopup: this.closePopup,\n      onChange: this.handleSelect,\n      onHeaderClick: this.switchToPrevMode,\n      initializeWith: parse_1.buildValue(this.parseInternalValue(), initialDate, localization, dateTimeFormat),\n      value: parse_1.buildValue(value, null, localization, dateTimeFormat, null),\n      minDate: parse_1.parseValue(minDate, dateTimeFormat, localization),\n      maxDate: parse_1.parseValue(maxDate, dateTimeFormat, localization),\n      localization: localization\n    };\n    var disableParsed = parse_1.parseArrayOrValue(disable, dateTimeFormat, localization);\n    var mode = this.state.mode;\n    var markedParsed = parse_1.parseArrayOrValue(marked, dateTimeFormat, localization);\n\n    if (mode === 'year') {\n      return React.createElement(YearPicker_1.default, __assign({}, pickerProps, {\n        disable: shared_1.getDisabledYears(disableParsed)\n      }));\n    }\n\n    if (mode === 'month') {\n      return React.createElement(MonthPicker_1.default, __assign({}, pickerProps, {\n        hasHeader: true,\n        disable: shared_1.getDisabledMonths(disableParsed)\n      }));\n    }\n\n    if (mode === 'day') {\n      return React.createElement(DayPicker_1.default, __assign({}, pickerProps, {\n        marked: markedParsed,\n        markColor: markColor,\n        disable: disableParsed\n      }));\n    }\n\n    if (mode === 'hour') {\n      return React.createElement(HourPicker_1.default, __assign({\n        timeFormat: this.props.timeFormat,\n        hasHeader: true\n      }, pickerProps, {\n        disable: disableParsed\n      }));\n    }\n\n    return React.createElement(MinutePicker_1.default, __assign({\n      timeFormat: this.props.timeFormat,\n      hasHeader: true\n    }, pickerProps, {\n      disable: disableParsed\n    }));\n  };\n  /**\r\n   * Component responsibility:\r\n   *  - parse input value\r\n   *  - handle underlying picker change\r\n   */\n\n\n  DateTimeInput.defaultProps = __assign({}, BaseInput_1.default.defaultProps, {\n    dateFormat: 'DD-MM-YYYY',\n    timeFormat: '24',\n    startMode: 'day',\n    divider: ' ',\n    icon: 'calendar',\n    preserveViewMode: true\n  });\n  DateTimeInput.propTypes = {\n    /** Currently selected value. */\n    value: PropTypes.string,\n\n    /** Moment datetime formatting string */\n    dateTimeFormat: PropTypes.string,\n\n    /** Moment date formatting string. */\n    dateFormat: PropTypes.string,\n\n    /** Time format [\"AMPM\", \"ampm\", \"24\"] */\n    timeFormat: PropTypes.string,\n\n    /** Date to display initially when no date is selected. */\n    initialDate: PropTypes.oneOfType([PropTypes.string, CustomPropTypes_1.default.momentObj, PropTypes.instanceOf(Date)]),\n\n    /** Date or list of dates that are displayed as disabled. */\n    disable: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string), CustomPropTypes_1.default.momentObj, PropTypes.arrayOf(CustomPropTypes_1.default.momentObj), PropTypes.instanceOf(Date), PropTypes.arrayOf(PropTypes.instanceOf(Date))]),\n\n    /** Maximum date that can be selected. */\n    maxDate: PropTypes.oneOfType([PropTypes.string, CustomPropTypes_1.default.momentObj, PropTypes.instanceOf(Date)]),\n\n    /** Minimum date that can be selected. */\n    minDate: PropTypes.oneOfType([PropTypes.string, CustomPropTypes_1.default.momentObj, PropTypes.instanceOf(Date)]),\n\n    /** Preserve viewmode on focus? */\n    preserveViewMode: PropTypes.bool,\n\n    /** Display mode to start. */\n    startMode: PropTypes.oneOf(['year', 'month', 'day']),\n\n    /** Date and time divider. */\n    divider: PropTypes.string,\n\n    /** If true, popup closes after selecting a date-time. */\n    closable: PropTypes.bool,\n\n    /**\r\n     * Called on clear.\r\n     *\r\n     * @param {SyntheticEvent} event - React's original SyntheticEvent.\r\n     * @param {object} data - All props and proposed value.\r\n     */\n    onClear: PropTypes.func,\n\n    /** Using the clearable setting will let users remove their selection from a calendar. */\n    clearable: PropTypes.bool,\n\n    /** Optional Icon to display inside the clearable Input. */\n    clearIcon: PropTypes.any,\n\n    /** Duration of the CSS transition animation in milliseconds. */\n    duration: PropTypes.number,\n\n    /** Named animation event to used. Must be defined in CSS. */\n    animation: PropTypes.string,\n    marked: PropTypes.oneOfType([CustomPropTypes_1.default.momentObj, CustomPropTypes_1.default.dateObject, PropTypes.arrayOf(CustomPropTypes_1.default.momentObj), PropTypes.arrayOf(CustomPropTypes_1.default.dateObject)]),\n    markColor: PropTypes.string,\n\n    /** Moment date localization. */\n    localization: PropTypes.string,\n    icon: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n    iconPosition: PropTypes.oneOf(['left', 'right']),\n    hideMobileKeyboard: PropTypes.bool\n  };\n  return DateTimeInput;\n}(BaseInput_1.default);\n\nexports.default = DateTimeInput;","map":null,"metadata":{},"sourceType":"script"}