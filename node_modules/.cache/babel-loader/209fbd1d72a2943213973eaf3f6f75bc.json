{"ast":null,"code":"import axios from 'axios';\nimport config from '../config';\n\nclass Replication {\n  constructor(db, replicationUrl, storageKey, time = 10000) {\n    this.db = db;\n    this.replicationUrl = replicationUrl;\n    this.storageKey = storageKey;\n    this.tryReplication = this.tryReplication.bind(this);\n    this.stopReplication = this.stopReplication.bind(this);\n    this.tryReplication().then(() => {\n      this.interval = window.setInterval(this.tryReplication, time);\n    });\n  }\n\n  stopReplication() {\n    window.clearInterval(this.interval);\n  }\n\n  async tryReplication() {\n    if (localStorage.getItem(this.storageKey) < new Date()) {\n      console.log(\"in\");\n\n      try {\n        let _ref = await axios.get(this.replicationUrl),\n            data = _ref.data;\n\n        await this.db.bulkDocs({\n          docs: data\n        });\n        localStorage.setItem(this.storageKey, this.getNextReplicationDate());\n      } catch (err) {\n        if (err.response) {\n          console.log(err);\n        } // else no response received that means the user is offline (or the server is not working)\n\n      }\n    }\n  }\n\n  getNextReplicationDate() {\n    let replicationHour = config.replication_starting_hour; // at 9am every morning the new data is here we have to refetch it\n\n    let date = new Date();\n    let nextDate = new Date(date.getFullYear(), date.getMonth(), date.getDay(), replicationHour);\n\n    if (date.getHours() >= replicationHour) {\n      nextDate.setDate(nextDate.getDate() + 1);\n    }\n\n    return nextDate;\n  }\n\n}\n\nconst replicateFromSQL = (db, replicationUrl, storageKey) => {\n  return new Replication(db, replicationUrl, storageKey);\n};\n\nexport default replicateFromSQL;","map":{"version":3,"sources":["/Users/antoine/Documents/DGCCRF/dgccrf-front/src/services/replicationHandler.js"],"names":["axios","config","Replication","constructor","db","replicationUrl","storageKey","time","tryReplication","bind","stopReplication","then","interval","window","setInterval","clearInterval","localStorage","getItem","Date","console","log","get","data","bulkDocs","docs","setItem","getNextReplicationDate","err","response","replicationHour","replication_starting_hour","date","nextDate","getFullYear","getMonth","getDay","getHours","setDate","getDate","replicateFromSQL"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,WAAnB;;AAEA,MAAMC,WAAN,CAAkB;AACdC,EAAAA,WAAW,CAACC,EAAD,EAAKC,cAAL,EAAqBC,UAArB,EAAiCC,IAAI,GAAG,KAAxC,EAA+C;AACtD,SAAKH,EAAL,GAAUA,EAAV;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AAEA,SAAKE,cAAL,GAAsB,KAAKA,cAAL,CAAoBC,IAApB,CAAyB,IAAzB,CAAtB;AACA,SAAKC,eAAL,GAAuB,KAAKA,eAAL,CAAqBD,IAArB,CAA0B,IAA1B,CAAvB;AAEA,SAAKD,cAAL,GAAsBG,IAAtB,CAA2B,MAAM;AAC7B,WAAKC,QAAL,GAAgBC,MAAM,CAACC,WAAP,CAAmB,KAAKN,cAAxB,EAAwCD,IAAxC,CAAhB;AACH,KAFD;AAIH;;AAEDG,EAAAA,eAAe,GAAG;AACdG,IAAAA,MAAM,CAACE,aAAP,CAAqB,KAAKH,QAA1B;AACH;;AAED,QAAMJ,cAAN,GAAuB;AACnB,QAAIQ,YAAY,CAACC,OAAb,CAAqB,KAAKX,UAA1B,IAAwC,IAAIY,IAAJ,EAA5C,EAAwD;AACpDC,MAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;;AACA,UAAI;AAAA,mBACe,MAAMpB,KAAK,CAACqB,GAAN,CAAU,KAAKhB,cAAf,CADrB;AAAA,YACMiB,IADN,QACMA,IADN;;AAEA,cAAM,KAAKlB,EAAL,CAAQmB,QAAR,CAAiB;AAAEC,UAAAA,IAAI,EAAEF;AAAR,SAAjB,CAAN;AACAN,QAAAA,YAAY,CAACS,OAAb,CAAqB,KAAKnB,UAA1B,EAAsC,KAAKoB,sBAAL,EAAtC;AAEH,OALD,CAKE,OAAOC,GAAP,EAAY;AACV,YAAIA,GAAG,CAACC,QAAR,EAAkB;AACdT,UAAAA,OAAO,CAACC,GAAR,CAAYO,GAAZ;AACH,SAHS,CAGT;;AACJ;AACJ;AAEJ;;AAEDD,EAAAA,sBAAsB,GAAG;AACrB,QAAIG,eAAe,GAAG5B,MAAM,CAAC6B,yBAA7B,CADqB,CACkC;;AACvD,QAAIC,IAAI,GAAG,IAAIb,IAAJ,EAAX;AACA,QAAIc,QAAQ,GAAG,IAAId,IAAJ,CAASa,IAAI,CAACE,WAAL,EAAT,EAA6BF,IAAI,CAACG,QAAL,EAA7B,EAA8CH,IAAI,CAACI,MAAL,EAA9C,EAA6DN,eAA7D,CAAf;;AACA,QAAIE,IAAI,CAACK,QAAL,MAAmBP,eAAvB,EAAwC;AACpCG,MAAAA,QAAQ,CAACK,OAAT,CAAiBL,QAAQ,CAACM,OAAT,KAAqB,CAAtC;AACH;;AACD,WAAON,QAAP;AACH;;AA5Ca;;AA+ClB,MAAMO,gBAAgB,GAAG,CAACnC,EAAD,EAAKC,cAAL,EAAqBC,UAArB,KAAoC;AACzD,SAAO,IAAIJ,WAAJ,CAAgBE,EAAhB,EAAoBC,cAApB,EAAoCC,UAApC,CAAP;AACH,CAFD;;AAIA,eAAeiC,gBAAf","sourcesContent":["import axios from 'axios';\nimport config from '../config';\n\nclass Replication {\n    constructor(db, replicationUrl, storageKey, time = 10000) {\n        this.db = db;\n        this.replicationUrl = replicationUrl;\n        this.storageKey = storageKey;\n\n        this.tryReplication = this.tryReplication.bind(this);\n        this.stopReplication = this.stopReplication.bind(this);\n\n        this.tryReplication().then(() => {\n            this.interval = window.setInterval(this.tryReplication, time);\n        })\n\n    }\n\n    stopReplication() {\n        window.clearInterval(this.interval);\n    }\n\n    async tryReplication() {\n        if (localStorage.getItem(this.storageKey) < new Date()) {\n            console.log(\"in\")\n            try {\n                let { data } = await axios.get(this.replicationUrl);\n                await this.db.bulkDocs({ docs: data });\n                localStorage.setItem(this.storageKey, this.getNextReplicationDate());\n\n            } catch (err) {\n                if (err.response) {\n                    console.log(err)\n                }// else no response received that means the user is offline (or the server is not working)\n            }\n        }\n\n    }\n\n    getNextReplicationDate() {\n        let replicationHour = config.replication_starting_hour // at 9am every morning the new data is here we have to refetch it\n        let date = new Date();\n        let nextDate = new Date(date.getFullYear(), date.getMonth(), date.getDay(), replicationHour)\n        if (date.getHours() >= replicationHour) {\n            nextDate.setDate(nextDate.getDate() + 1);\n        }\n        return nextDate;\n    }\n}\n\nconst replicateFromSQL = (db, replicationUrl, storageKey) => {\n    return new Replication(db, replicationUrl, storageKey)\n};\n\nexport default replicateFromSQL;"]},"metadata":{},"sourceType":"module"}