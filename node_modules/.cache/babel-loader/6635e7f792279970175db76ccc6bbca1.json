{"ast":null,"code":"import axios from 'axios';\nimport config from '../config';\nimport moment from 'moment';\n\nclass Replication {\n  constructor(db, replicationUrl, storageKey, time = 10000) {\n    this.db = db;\n    this.replicationUrl = replicationUrl;\n    this.storageKey = storageKey;\n    this.tryReplication = this.tryReplication.bind(this);\n    this.stopReplication = this.stopReplication.bind(this);\n    this.tryReplication().then(() => {\n      this.interval = window.setInterval(this.tryReplication, time);\n    });\n  }\n\n  stopReplication() {\n    window.clearInterval(this.interval);\n    window.localStorage.removeItem(this.storageKey);\n  }\n\n  async tryReplication() {\n    let nextChangeDate = moment(localStorage.getItem(this.storageKey)).format(\"YYYY-MM-DDTHH:mm:SSS\");\n    console.log(nextChangeDate < moment(new Date()).format(\"YYYY-MM-DDTHH:mm:SSS\"));\n\n    if (nextChangeDate < moment(new Date()).format(\"YYYY-MM-DDTHH:mm:SSS\")) {\n      try {\n        let _ref = await axios.get(this.replicationUrl),\n            data = _ref.data;\n\n        await this.db.bulkDocs({\n          docs: data\n        });\n        localStorage.setItem(this.storageKey, this.getNextReplicationDate());\n      } catch (err) {\n        if (err.response) {\n          console.log(err);\n        } // else no response received that means the user is offline (or the server is not working)\n\n      }\n    }\n  }\n\n  getNextReplicationDate() {\n    let replicationHour = config.replication_starting_hour; // at 9am every morning the new data is here we have to refetch it\n\n    let date = new Date();\n    let nextDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), replicationHour);\n\n    if (date.getHours() >= replicationHour) {\n      nextDate.setDate(nextDate.getDate() + 1);\n    }\n\n    return nextDate;\n  }\n\n}\n\nconst replicateFromSQL = (db, replicationUrl, storageKey) => {\n  return new Replication(db, replicationUrl, storageKey);\n};\n\nexport default replicateFromSQL;","map":{"version":3,"sources":["/Users/antoine/Documents/DGCCRF/dgccrf-front/src/services/replicationHandler.js"],"names":["axios","config","moment","Replication","constructor","db","replicationUrl","storageKey","time","tryReplication","bind","stopReplication","then","interval","window","setInterval","clearInterval","localStorage","removeItem","nextChangeDate","getItem","format","console","log","Date","get","data","bulkDocs","docs","setItem","getNextReplicationDate","err","response","replicationHour","replication_starting_hour","date","nextDate","getFullYear","getMonth","getDate","getHours","setDate","replicateFromSQL"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,MAAP,MAAmB,QAAnB;;AAEA,MAAMC,WAAN,CAAkB;AACdC,EAAAA,WAAW,CAACC,EAAD,EAAKC,cAAL,EAAqBC,UAArB,EAAiCC,IAAI,GAAG,KAAxC,EAA+C;AACtD,SAAKH,EAAL,GAAUA,EAAV;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AAEA,SAAKE,cAAL,GAAsB,KAAKA,cAAL,CAAoBC,IAApB,CAAyB,IAAzB,CAAtB;AACA,SAAKC,eAAL,GAAuB,KAAKA,eAAL,CAAqBD,IAArB,CAA0B,IAA1B,CAAvB;AAEA,SAAKD,cAAL,GAAsBG,IAAtB,CAA2B,MAAM;AAC7B,WAAKC,QAAL,GAAgBC,MAAM,CAACC,WAAP,CAAmB,KAAKN,cAAxB,EAAwCD,IAAxC,CAAhB;AACH,KAFD;AAIH;;AAEDG,EAAAA,eAAe,GAAG;AACdG,IAAAA,MAAM,CAACE,aAAP,CAAqB,KAAKH,QAA1B;AACAC,IAAAA,MAAM,CAACG,YAAP,CAAoBC,UAApB,CAA+B,KAAKX,UAApC;AACH;;AAED,QAAME,cAAN,GAAuB;AACnB,QAAIU,cAAc,GAAGjB,MAAM,CAACe,YAAY,CAACG,OAAb,CAAqB,KAAKb,UAA1B,CAAD,CAAN,CAA8Cc,MAA9C,CAAqD,sBAArD,CAArB;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYJ,cAAc,GAAGjB,MAAM,CAAC,IAAIsB,IAAJ,EAAD,CAAN,CAAmBH,MAAnB,CAA0B,sBAA1B,CAA7B;;AACA,QAAIF,cAAc,GAAGjB,MAAM,CAAC,IAAIsB,IAAJ,EAAD,CAAN,CAAmBH,MAAnB,CAA0B,sBAA1B,CAArB,EAAwE;AACpE,UAAI;AAAA,mBACe,MAAMrB,KAAK,CAACyB,GAAN,CAAU,KAAKnB,cAAf,CADrB;AAAA,YACMoB,IADN,QACMA,IADN;;AAEA,cAAM,KAAKrB,EAAL,CAAQsB,QAAR,CAAiB;AAAEC,UAAAA,IAAI,EAAEF;AAAR,SAAjB,CAAN;AACAT,QAAAA,YAAY,CAACY,OAAb,CAAqB,KAAKtB,UAA1B,EAAsC,KAAKuB,sBAAL,EAAtC;AACH,OAJD,CAIE,OAAOC,GAAP,EAAY;AACV,YAAIA,GAAG,CAACC,QAAR,EAAkB;AACdV,UAAAA,OAAO,CAACC,GAAR,CAAYQ,GAAZ;AACH,SAHS,CAGT;;AACJ;AACJ;AAEJ;;AAEDD,EAAAA,sBAAsB,GAAG;AACrB,QAAIG,eAAe,GAAGhC,MAAM,CAACiC,yBAA7B,CADqB,CACkC;;AACvD,QAAIC,IAAI,GAAG,IAAIX,IAAJ,EAAX;AACA,QAAIY,QAAQ,GAAG,IAAIZ,IAAJ,CAASW,IAAI,CAACE,WAAL,EAAT,EAA6BF,IAAI,CAACG,QAAL,EAA7B,EAA8CH,IAAI,CAACI,OAAL,EAA9C,EAA8DN,eAA9D,CAAf;;AACA,QAAIE,IAAI,CAACK,QAAL,MAAmBP,eAAvB,EAAwC;AACpCG,MAAAA,QAAQ,CAACK,OAAT,CAAiBL,QAAQ,CAACG,OAAT,KAAqB,CAAtC;AACH;;AACD,WAAOH,QAAP;AACH;;AA7Ca;;AAgDlB,MAAMM,gBAAgB,GAAG,CAACrC,EAAD,EAAKC,cAAL,EAAqBC,UAArB,KAAoC;AACzD,SAAO,IAAIJ,WAAJ,CAAgBE,EAAhB,EAAoBC,cAApB,EAAoCC,UAApC,CAAP;AACH,CAFD;;AAIA,eAAemC,gBAAf","sourcesContent":["import axios from 'axios';\nimport config from '../config';\nimport moment from 'moment'\n\nclass Replication {\n    constructor(db, replicationUrl, storageKey, time = 10000) {\n        this.db = db;\n        this.replicationUrl = replicationUrl;\n        this.storageKey = storageKey;\n\n        this.tryReplication = this.tryReplication.bind(this);\n        this.stopReplication = this.stopReplication.bind(this);\n\n        this.tryReplication().then(() => {\n            this.interval = window.setInterval(this.tryReplication, time);\n        })\n\n    }\n\n    stopReplication() {\n        window.clearInterval(this.interval);\n        window.localStorage.removeItem(this.storageKey);\n    }\n\n    async tryReplication() {\n        let nextChangeDate = moment(localStorage.getItem(this.storageKey)).format(\"YYYY-MM-DDTHH:mm:SSS\");\n        console.log(nextChangeDate < moment(new Date()).format(\"YYYY-MM-DDTHH:mm:SSS\"))\n        if (nextChangeDate < moment(new Date()).format(\"YYYY-MM-DDTHH:mm:SSS\")) {\n            try {\n                let { data } = await axios.get(this.replicationUrl);\n                await this.db.bulkDocs({ docs: data });\n                localStorage.setItem(this.storageKey, this.getNextReplicationDate());\n            } catch (err) {\n                if (err.response) {\n                    console.log(err)\n                }// else no response received that means the user is offline (or the server is not working)\n            }\n        }\n\n    }\n\n    getNextReplicationDate() {\n        let replicationHour = config.replication_starting_hour // at 9am every morning the new data is here we have to refetch it\n        let date = new Date();\n        let nextDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), replicationHour);\n        if (date.getHours() >= replicationHour) {\n            nextDate.setDate(nextDate.getDate() + 1);\n        }\n        return nextDate;\n    }\n}\n\nconst replicateFromSQL = (db, replicationUrl, storageKey) => {\n    return new Replication(db, replicationUrl, storageKey)\n};\n\nexport default replicateFromSQL;"]},"metadata":{},"sourceType":"module"}